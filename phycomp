<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>2-Player Air Hockey</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block;background:#1a5c1a;width:100%;height:100%}
  #scoreBoard{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:2em;font-family:Arial;text-align:center;pointer-events:none;z-index:10}
  #p1Score{position:fixed;top:10px;left:10px;color:#fff;font-size:1.5em;font-family:Arial;z-index:10}
  #p2Score{position:fixed;bottom:10px;left:10px;color:#fff;font-size:1.5em;font-family:Arial;z-index:10}
  #message{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#ffff00;font-size:1.2em;font-family:Arial;text-align:center;pointer-events:none;z-index:10}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="p1Score">P1: 0</div>
<div id="p2Score">P2: 0</div>
<div id="message"></div>
<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;
  
  window.addEventListener('resize', () => {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  });

  // Game objects
  const puck = {
    x: W / 2,
    y: H / 2,
    vx: 0,
    vy: 0,
    radius: 8,
    mass: 1
  };

  const mallets = {
    p1: { x: W / 2, y: H - 50, radius: 25, touchId: null },
    p2: { x: W / 2, y: 50, radius: 25, touchId: null }
  };

  let score = { p1: 0, p2: 0 };
  let goalScored = null;
  const gravity = 0;
  const friction = 0.98;
  const restitution = 0.95;
  const centerLineY = H / 2;
  const goalWidth = 80;
  const goalX1 = (W - goalWidth) / 2;
  const goalX2 = goalX1 + goalWidth;

  // Touch tracking
  const touches = {};

  document.addEventListener('touchstart', (e) => {
    for (let touch of e.changedTouches) {
      touches[touch.identifier] = { x: touch.clientX, y: touch.clientY };
      
      // Assign to player based on Y position
      if (touch.clientY > centerLineY && !mallets.p1.touchId) {
        mallets.p1.touchId = touch.identifier;
      } else if (touch.clientY < centerLineY && !mallets.p2.touchId) {
        mallets.p2.touchId = touch.identifier;
      }
    }
  });

  document.addEventListener('touchmove', (e) => {
    for (let touch of e.changedTouches) {
      if (touches[touch.identifier]) {
        touches[touch.identifier].x = touch.clientX;
        touches[touch.identifier].y = touch.clientY;
      }
    }
    e.preventDefault();
  });

  document.addEventListener('touchend', (e) => {
    for (let touch of e.changedTouches) {
      if (mallets.p1.touchId === touch.identifier) {
        mallets.p1.touchId = null;
      }
      if (mallets.p2.touchId === touch.identifier) {
        mallets.p2.touchId = null;
      }
      delete touches[touch.identifier];
    }
  });

  function updateMallets() {
    // Update P1 mallet
    if (mallets.p1.touchId !== null && touches[mallets.p1.touchId]) {
      let touch = touches[mallets.p1.touchId];
      mallets.p1.x = touch.x;
      mallets.p1.y = Math.min(touch.y, centerLineY - 10);
    }
    
    // Update P2 mallet
    if (mallets.p2.touchId !== null && touches[mallets.p2.touchId]) {
      let touch = touches[mallets.p2.touchId];
      mallets.p2.x = touch.x;
      mallets.p2.y = Math.max(touch.y, centerLineY + 10);
    }
  }

  function updatePuck(dt) {
    // Apply friction
    puck.vx *= friction;
    puck.vy *= friction;

    // Update position
    puck.x += puck.vx * dt;
    puck.y += puck.vy * dt;

    // Wall collisions (left/right)
    if (puck.x - puck.radius < 0) {
      puck.x = puck.radius;
      puck.vx = Math.abs(puck.vx) * restitution;
    }
    if (puck.x + puck.radius > W) {
      puck.x = W - puck.radius;
      puck.vx = -Math.abs(puck.vx) * restitution;
    }

    // Goal detection (top)
    if (puck.y < 0 && puck.x > goalX1 && puck.x < goalX2) {
      score.p1++;
      goalScored = 'P1';
      resetPuck();
    }

    // Goal detection (bottom)
    if (puck.y > H && puck.x > goalX1 && puck.x < goalX2) {
      score.p2++;
      goalScored = 'P2';
      resetPuck();
    }

    // Center line collision (puck can't cross)
    if (puck.y < centerLineY && puck.vy < 0) {
      puck.vy = Math.abs(puck.vy) * restitution;
      puck.y = centerLineY;
    }
    if (puck.y > centerLineY && puck.vy > 0) {
      puck.vy = -Math.abs(puck.vy) * restitution;
      puck.y = centerLineY;
    }

    // Mallet collisions
    [mallets.p1, mallets.p2].forEach(mallet => {
      const dx = puck.x - mallet.x;
      const dy = puck.y - mallet.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist < puck.radius + mallet.radius) {
        const nx = dx / dist;
        const ny = dy / dist;
        
        // Separate puck from mallet
        const overlap = puck.radius + mallet.radius - dist;
        puck.x += nx * overlap;
        puck.y += ny * overlap;
        
        // Reflect velocity
        const speed = 400;
        puck.vx = nx * speed;
        puck.vy = ny * speed;
      }
    });
  }

  function resetPuck() {
    puck.x = W / 2;
    puck.y = H / 2;
    puck.vx = 0;
    puck.vy = 0;
  }

  function draw() {
    // Clear canvas
    ctx.fillStyle = '#1a5c1a';
    ctx.fillRect(0, 0, W, H);

    // Draw center line
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.setLineDash([10, 10]);
    ctx.beginPath();
    ctx.moveTo(0, centerLineY);
    ctx.lineTo(W, centerLineY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw goals
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect(goalX1, -20, goalWidth, 20);
    ctx.fillRect(goalX1, H, goalWidth, 20);

    // Draw goal lines
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(goalX1, 0);
    ctx.lineTo(goalX2, 0);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(goalX1, H);
    ctx.lineTo(goalX2, H);
    ctx.stroke();

    // Draw puck
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(puck.x, puck.y, puck.radius, 0, Math.PI * 2);
    ctx.fill();

    // Draw mallets
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(mallets.p1.x, mallets.p1.y, mallets.p1.radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#00ffff';
    ctx.beginPath();
    ctx.arc(mallets.p2.x, mallets.p2.y, mallets.p2.radius, 0, Math.PI * 2);
    ctx.fill();

    // Draw scores
    document.getElementById('p1Score').textContent = `P1: ${score.p1}`;
    document.getElementById('p2Score').textContent = `P2: ${score.p2}`;

    // Draw goal message
    if (goalScored) {
      document.getElementById('message').textContent = `${goalScored} SCORED!`;
      setTimeout(() => {
        goalScored = null;
        document.getElementById('message').textContent = '';
      }, 1000);
    }
  }

  let lastTime = Date.now();
  function gameLoop() {
    const now = Date.now();
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;

    updateMallets();
    updatePuck(dt);
    draw();

    requestAnimationFrame(gameLoop);
  }

  gameLoop();
})();
</script>
</body>
</html>